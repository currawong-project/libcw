{

      poly: {
        vars: {
	  count:        { type:uint, flags:["init"], value:1,     doc:"Count of network duplicates." },
	  parallel_fl:  { type:bool, flags:["init"], value:false, doc:"True to run voices concurrently." }
	  thread_cnt:   { type:uint, flags:["init"], value:5,     doc:"Count of threads to use in parallel mode."},
	  cpu_affinityL:{ type:cfg,  flags:["init"], value:{}     doc:"List of CPU affinities for each thread. List must be empty or count of elements must match 'thread_cnt'."},
	  preset_sfx_id:{ type:uint,                 value:-1,    doc:"The voice index to assign the prefix to or -1 if there is no preset to assign." },
	  preset_label: { type:string,               value:"",    doc:"The network preset to activate on voice channel 'preset_idx'." },
	}
      }


      balance: {
        doc: [ "Stereo balance control." ]
        vars: {
	   in:      { type:coeff, value:0.5, doc:"Input value" },
	   out:     { type:coeff, doc:"Ouput value. Same as input value."},
	   inv_out: { type:coeff, doc:"1.0 minus output value."}
	}
      }

      midi_in: {
        doc: [ "MIDI input device."],
	vars: {
	  dev_label: { type:string, value:"<all>", doc:"MIDI input device label. Set to '<all>' to accept input from any device."},
	  port_label:{ type:string, value:"<all>", doc:"MIDI input device port label. Set to '<all>' to accept input from any device."},
	  out:       { type:midi,                  doc:"MIDI input port." },
	  r_out:     { type:record,                doc:"MIDI record.",
	                  fmt: {
			    alloc_cnt:1024,
			    fields: {
			      midi: { type:m3,             doc:"MIDI channel event message" },
			    }
			  }
			}
	}
      }
      
      midi_out: {
        doc: [ "MIDI output device."],
	vars: {	  
	  dev_label: { type:string, flags:["init"],           doc:"MIDI output device label."},
	  port_label:{ type:string, flags:["init"],           doc:"MIDI output device port label."},
	  buf_cnt:   { type:uint,   flags:["init"], value:64, doc:"MIDI message buffer count." },
	  in:        { type:midi,                             doc:"MIDI messages to send."},
	  rin:       { type:record, fmt:{ required:["midi"]}, doc:"Record input. (must have 'midi' field)"},
	  print_fl:  { type:bool, value:false,        doc:"Print the output to the console."}
	  enable_fl: { type:bool, value:true,        doc:"Enable the output port."}
	}
      }

      audio_in: {
        doc: [ "Audio input device." ],
        vars: {
	  dev_label: { type:string,  doc:"Audio device label." },
          out:       { type:audio,   doc:"Audio output" },
          }
      }

      audio_out: {
        doc: [ "Audio output device." ],
        vars: {
          dev_label: { type:string,               flags:["init"], doc:"Audio device label." },
          in:        { type:audio, flags:["src"],                 doc:"Audio input." }
          }
      }
      
      audio_file_in: {
        vars: {
          fname: {   type:string, doc:"Audio file name." },
          out:{      type:audio,  doc:"Audio file output" },
	  on_off:{   type:bool, value:false, doc:"1=on 0=off" },,
	  seekSecs:{ type:ftime, flags:["notify"], value:0.0, doc:"Seek to the specified seconds offset." } 
          eofFl:{     type:bool,  value: true, doc:"Set the system 'halt' flag when the audio is completely read."},
          }
      }

      audio_file_out: {
        vars: {
          fname: { type:string,               doc:"Audio file name." },
	  bits:  { type:uint, value:32u,      doc:"Audio file word width. (8,16,24,32,0=float32)."},
          in:    { type:audio, flags:["src"], doc:"Audio file input." }
          }
      }

      audio_buf_file_out {
        doc: [ "Store all incoming audio in an expandable audio buffer and then write it by triggering the 'write' input.",
	       "The audio file name is formed as '<dir>/<fname>_###.wav' where ### is automatically selected to form a unique file name." ]
        vars: {
	  dir:       { type:string,          flags:["init"],                doc:"Audio file directory."},
          fname:     { type:string,          flags:["init"],                doc:"Audio file name prefix." },
	  bits:      { type:uint, value:32u, flags:["init"],                doc:"Audio file word width. (8,16,24,32,0=float32)."},
	  init_secs: { type:double,          flags:["init"],   value:60.0,  doc:"Initial audio buffer size in seconds."},
	  add_secs:  { type:double,          flags:["init"],   value:30.0,  doc:"Incremental audio buffer expansion duration in seconds."},
	  "reset":   { type:all,             flags:["notify"], value:false, doc:"Drop the current cache contents and prepare to refill it."},
	  "write":   { type:all,             flags:["notify"], value:false, doc:"Write the contents of the buffer to <dir>/<fname>_###."}
          in:        { type:audio,           flags:["src"],                 doc:"Audio file input." }
          }
      }

      audio_gain: {
        vars: {
	   in:   { type:audio, flags:["src"], doc:"Audio input." },
	   gain: { type:coeff, value:1.0, doc:"Gain coefficient." }
	   out:  { type:audio,             doc:"Audio output." },
        }
	presets:
	{
	  mute_off: { gain:1 },
	  mute_on:  { gain:0 }
	}
      }

      audio_split: {
         vars: {
	   in:     { type:audio, flags:["src"],                     doc:"Audio input." },
	   select: { type:cfg,   flags:["init"],                    doc:"A list of integers where each value selects an output channel for the associated input channel." }
	   igain:  { type:coeff, flags:["notify"],        value:1.0, doc:"Audio gain for each input channel." }
	   ogain:  { type:coeff, flags:["mult","notify"], value:1.0, doc:"Audio gain for each output channel." }
	   out:    { type:audio, flags:["mult"],                     doc:"Audio output." },
	 }

        presets:
	{
	   mute_off: { gain:1   },
	   mute_on:  { gain:0 },
	}
      }


      audio_duplicate: {
         vars: {
	   in:        { type:audio, flags:["src"], doc:"Audio input."},
	   duplicate: { type: uint,            doc:"Count of times to repeat this channel." },
	   gain:      { type: coeff, value:1.0, doc:"Audio gain." },
	   out:       { type:audio,             doc:"Audio output containing repeat * input channel count channels."}
	 }
      }

     audio_merge: {     
        vars: {
	  in:       { type:audio,            flags:["src", "mult"], doc:"Audio input channel." },
	  gain:     { type:coeff,  value: 1, flags:["src", "mult"], doc:"Input channel gain." },
	  out_gain: { type:coeff,  value: 1,                        doc:"Output gain" },
          out:      { type:audio,                                   doc:"Audio output. Channel count is the sum of the input channel count." },	
	}
      }

      audio_mix: {
         vars: {
	   in:    { type:audio, flags:["src","mult"],                doc:"Audio input." },
	   igain: { type:coeff, flags:["notify","mult"], value:0.5,  doc:"Input audio gain." },
	   ogain: { type:coeff, flags:["notify"],        value:1.0,  doc:"Output gain." },
	   out:   { type:audio,                                      doc:"Audio output. Output channel count is the maximum number of channels among the input signals." },
	 }
      }

      audio_marker: {
        vars: {
	  in:      { type:audio, flags:["src"],             doc:"Audio input."},
	  trigger: { type:all,   flags:["notify"], value:0, doc:"Marker trigger."},
	  out:     { type:audio,                            doc:"Audio output."},
	}
      }

      audio_delay: {
        vars: {
	   in:         { type:audio, flags:["src"],   doc:"Audio input." },
	   maxDelayMs: { type:ftime, value:1000.0     doc:"Maximum possible delay in milliseconds." },
	   delayMs:    { type:ftime, flags:["notify"], doc:"Delay in milliseconds." },
	   out:        { type:audio,                  doc:"Audio output." },
	}
      }

      audio_silence: {
        vars: {
      	  srate: { type:srate,  value:0, flags:["init"], doc:"Signal sample rate. 0=Use default system sample rate"},
	  ch_cnt: { type:uint,   value:1, flags:["init"], doc:"Count of output audio channels. (e.g. 1=mono, 2=stereo, ...)"},
	  out:   { type:audio,                           doc:"Audio signal containing only 0."},
        }
      }


      sine_tone: {
        vars: {
	  srate:     { type:srate, value:0,			doc:"Sine tone sample rate. 0=Use default system sample rate"}
	  ch_cnt:    { type:uint,  value:2,  flags:["init"],	doc:"Output signal channel count."},
	  hz:        { type:coeff, value:440.0,			doc:"Frequency in Hertz."},
	  phase:     { type:coeff, value:0.0,			doc:"Offset phase in radians."},
	  dc:        { type:coeff, value:0.0,			doc:"DC offset applied after gain."},
	  gain:      { type:coeff, value:0.8,			doc:"Signal frequency."},	  
          out:       { type:audio,				doc:"Audio output" },
          }

	presets: {
	  a220 : { hz:220 },
	  a440 : { hz:440 },
	  a880 : { hz:880 },
          mono:  { ch_cnt:1, gain:0.75 },
	  lfo1:  { hz:1, phase:0.11 },
	  lfo2:  { hz:2, phase:0.22 },
	  lfo3:  { hz:3, phase:0.33 },
	}
      }

      pv_analysis: {
        vars: {
          in:		{ type:audio,    flags:["src"],                  doc:"Audio input." },
	  enable:       { type:bool,                      value: true,   doc:"Enable/disable the processor."}
	  maxWndSmpN:	{ type:uint,                      value: 1024,   doc:"Maximum window sample count." },
          wndSmpN:	{ type:uint,     flags:["notify"],value:  512,   doc:"Window sample count." },
          hopSmpN:	{ type:uint,                      value:  128,   doc:"Hop sample count." },
          hzFl:		{ type:bool,                      value:false,   doc:"Calculate frequency via the method of phase change of each bin." },
          out:		{ type:spectrum,                                 doc:"Spectrum output." }
          }

        presets: {

	  dry: {
	    wndSmpN:  512,
	    hopSmpN:  128	  
	  }

	  kc: {
	    wndSmpN:  512,
	    hopSmpN:  128
	  }
	  
          a: {
	    wndSmpN:  [512,1024],
	    hopSmpN:  128
          }

          b: {
	    wndSmpN:  [1024,512],
	    hopSmpN:  128
          }

          c: {
	    wndSmpN:  [512,1024],
	    hopSmpN:  128
          }

          d: {
	    wndSmpN:  [1024,512],
	    hopSmpN:  128
          }

          f_1: {
	    wndSmpN:  [512,1024],
	    hopSmpN:  128
          }
	  
          f_2: {
	    wndSmpN:  [1024,512],
	    hopSmpN:  128
          }

          f_3: {
	    wndSmpN:  [512,1024],
	    hopSmpN:  128
          }

          f_4: {
	    wndSmpN:  [1024,512],
	    hopSmpN:  128
          }

          g: {
	    wndSmpN:  [512,1024],
	    hopSmpN:  128
          }
	  
          g_a: {
	    wndSmpN:  [1024,512],
	    hopSmpN:  128
          }

          g_1_a: {
	    wndSmpN:  [512,1024],
	    hopSmpN:  128
          }

          g_1_d: {
	    wndSmpN:  [1024,512],
	    hopSmpN:  128
          }	  
	}
      }

      pv_synthesis: {
        vars: {
          in:        { type:spectrum,  flags:["src"],  doc:"Spectrum input." },
	  enable:    { type:bool,     value: true,     doc:"Enable/disable the processor."}	  
          out:       { type:audio,                     doc:"Audio output." }
          }
      }

      spec_dist: {
        vars: {
          in:       { type:spectrum, flags:["src"],                  doc:"Spectrum input." },
	  enable:   { type:bool,     flags:["notify"], value: true,  doc:"Enable/disable this processor."},
	  bypass:   { type:bool,     flags:["notify"], value: false, doc:"Copy input to output without transform."},
          ceiling:  { type:coeff,    flags:["notify"], value: 30.0,  doc:"Ceiling parameter."},
          expo:     { type:coeff,    flags:["notify"], value:  2.0,  doc:"Exponent parameter."},
          thresh:   { type:coeff,    flags:["notify"], value: 54.0,  doc:"Threshold parameter."},
          upr:      { type:coeff,    flags:["notify"], value: -0.7,  doc:"Upper slope parameter."},
          lwr:      { type:coeff,    flags:["notify"], value:  2.0,  doc:"Lower slope  parameter."},
          mix:      { type:coeff,    flags:["notify"], value:  0.0,  doc:"Basic/Bump Mix parameter."},

          out:      { type:spectrum,          doc:"Spectrum output." },

          }
          
        presets: {

	  dry: {
	       
	  }

	  kc: {
	    ceiling:  20.0,
	    expo:      2.0,
	    thresh:   65.0,
	    upr:       0.0,
	    lwr:       2.0,
	    mix:       0.0
	  }
	  
          a: {
            ceiling:  20.0
            expo:     2.0
            thresh:   60.0
            upr:      [   -1.1, -0.99],
            lwr:      2.0
            mix:      0.0
          }

          b: {
            ceiling:  20.0
            expo:      2.0
            thresh:   [   77.0, 74.0 ], 
            upr:      -0.5
            lwr:      [    3.0,  2.0 ],
            mix:       0.0
          }

          c: {
            ceiling:  20.0
            expo:      2.0
            thresh:   80.0
            upr:      -0.5
            lwr:       5.0
            mix:       0.0
          }

          d: {
            ceiling:  20.0
            expo:      2.0
            thresh:   70.0
            upr:    [ -3.9, 04.5]
            lwr:       4.0
            mix:       0.0
          }

          f_1: {
            ceiling:  20.0
            expo:      2.0
            thresh:   50.0
            upr:      -3.0
            lwr:       1.0
            mix:       0.0
          }
	  
          f_2: {
            ceiling:  20.0
            expo:      2.0
            thresh:   60.0
            upr:      -3.0
            lwr:       1.0
            mix:       0.0
          }

          f_3: {
            ceiling:  20.0
            expo:      2.0
            thresh:   55.0
            upr:      -3.0
            lwr:       1.0
            mix:       0.0
          }

          f_4: {
            ceiling:  20.0
            expo:      2.0
            thresh:   55.0
            upr:      -5.0
            lwr:       1.0
            mix:       0.0
          }

          g: {
            ceiling:  40.0
            expo:      8.0
            thresh:   [60.0 64.0]
            upr:      -0.7
            lwr:       8.0
            mix:       1.0
          }
	  
          g_a: {
            ceiling:  40.0
            expo:      2.0
            thresh:   [50.0 54.0]
            upr:      -0.7
            lwr:       2.0
            mix:       1.0
          }

          g_1_a: {
            ceiling:  20.0
            expo:      2.0
            thresh:   [50.0 54.0]
            upr:      -0.7
            lwr:       8.0
            mix:       1.0
          }

          g_1_d: {
            ceiling:  [60.0 64.0]
            expo:     [ 7.0  5.0]
            thresh:   [40.0 34.0]
            upr:      [-0.4 -0.3]
            lwr:      [ 7.0  5.0]
            mix:        1.0
          }
	}  
      }
      

      compressor: {
        vars: {
          in:        { type:audio, flags:["src"],                   doc:"Audio input." },
	  enable:    { type:bool,  flags:["notify"], value:  true,  doc:"Same as bypass with opposite polarity." },
          bypass:    { type:bool,  flags:["notify"], value:  false, doc:"Bypass the compressor."},
	  igain:     { type:coeff, flags:["notify"], value:    1.0, doc:"Input gain."},
	  thresh:    { type:coeff, flags:["notify"], value:   90.0, doc:"Attack threshold in dB."},
	  ratio:     { type:coeff, flags:["notify"], value:    2.0, doc:"Compression ratio."},
	  atk_ms:    { type:coeff, flags:["notify"], value:   20.0, doc:"Attack time in milliseconds."},
	  rls_ms:    { type:coeff, flags:["notify"], value:   20.0, doc:"Release time in milliseconds."},
	  wnd_ms:    { type:coeff, flags:["notify"], value:  200.0, doc:"RMS calc. window length in milliseconds."},
	  maxWnd_ms: { type:coeff, flags:["notify"], value: 1000.0, doc:"Maximim (allocated) window length in milliseconds."},
	  ogain:     { type:coeff, flags:["notify"], value:    1.0, doc:"Output gain."},	  
          out:       { type:audio,                                  doc:"Audio output." },	
	}
	
	presets: {
	  dflt: {
	     igain:   3.0
	     thresh: 60.0
	     ratio:   5.0
	     atk_ms:  5.0
	     rls_ms: 20.0
	     wnd_ms:100.0
	     ogain:   1.0
	  }
	  
	  kc: {
	     bypass:   false
	     igain:     3.0
	     thresh:   80.0
	     ratio:     2.0
	     atk_ms:   20.0
	     rls_ms: 1000.0
	     wnd_ms:  200.0
	     ogain:     1.0
	  }

	  input: {
              bypass: false
  	      igain:   2.0
	      thresh: 30.0
	      ratio:  12.0
	      atk_ms:  5.0
	      rls_ms: 20.0
	      wnd_ms: 20.0
	      ogain:   0.5	  
	  }

	  dry: {
	       
	  }

	   a: {
	     igain: 6.0
	     ogain: 1.0
	  }

	   b: {
	     igain: 10.0
	     ogain: 1.0
	  }

	   c: {
	     igain: 11.0
	     ogain: 1.0
	  }

	  d: {
	     igain: 9.0
	     ogain: 1.0
	  }

	  f_1: {
	     igain: 6.0
	     ogain: 1.0
	  }

	  f_2: {
	     igain: 6.0
	     ogain: 1.0
	  }

	  f_3: {
	     igain: 6.0
	     ogain: 1.0
	  }
	  
	  f_4: {
	     igain: 6.0
	     ogain: 1.0
	  }
	  
	  g: {
	     igain: 10.0
	     ogain: 0.75	
	  }
	  
	  g_a: {
	     igain: 10.0
	     ogain: 0.75
	  }

	  g_1_a: {
	     igain: 10.0
	     ogain: 0.75
	  }

	  g_1_d: {
	     igain: 10.0
	     ogain: 0.75
	  }


	}
      }

      limiter: {
        vars: {
          in:        { type:audio, flags:["src"],                   doc:"Audio input." },	  
          bypass:    { type:bool,  flags:["notify"], value:  false, doc:"Bypass the limiter."},
	  igain:     { type:coeff, flags:["notify"], value:    1.0, doc:"Input gain."},
	  thresh:    { type:coeff, flags:["notify"], value:    0.0, doc:"Linear (0.0-1.0) threshold."},
	  ogain:     { type:coeff, flags:["notify"], value:    1.0, doc:"Output gain."},	  
          out:       { type:audio,                                  doc:"Audio output." },	
	}
	
	presets: {
	    dflt: {
		bypass: false,
		igain:   1.0
		thresh:  0.9,
		ogain:   1.0
	  }

	}
      }

      dc_filter: {
        vars: {
          in:        { type:audio, flags:["src"], doc:"Audio input." },	  
          bypass:    { type:bool, value:  false, doc:"Bypass the DC filter."},
	  gain:      { type:coeff, value:    1.0, doc:"Output gain."},
          out:       { type:audio,               doc:"Audio output." },	
	}
	
	presets: {
	    dflt: {
		bypass: false,
		gain:   1.0
	  }

	}
      }

      audio_meter: {
        vars: {
	  in:        { type:audio,                flags:["src"],  doc:"Audio input." },
	  dbFl:      { type:bool,   value: true,                  doc:"Output in Decibels." },
	  wndMs:     { type:ftime,  value: 100.0, flags:["init"], doc:"RMS window length in milliseconds." },
	  consoleFl: { type:bool,   value: false,                 doc:"Print the output to the console." },
	  peakDb:    { type:coeff,  value: -10.0,                 doc:"Peak threshold." },
	  out:       { type:coeff,  value: 0.0,                   doc:"Meter output.", ui:{ type:meter, flags:[ horizontal ] } },
	  peakFl:    { type:bool,   value: false,                 doc:"Peak output." }
	  clipFl:    { type:bool,   value: false,                 doc:"Clip indicator output."},
	  rpt_ms:    { type:uint,   value:0,      flags:["init"], doc:"Report period in ms or 0 for no report."},
	}
      }

      sample_hold: {
         vars: {
	   in:        { type:audio, flags:["src"],  doc:"Audio input source." },
	   period_ms: { type:ftime, flags:["notify"], value:50,       doc:"Sample period in milliseconds." },
	   out:       { type:sample,                  value:0.0,      doc:"First value in the sample period." },
	   mean:      { type:sample,                  value:0.0,      doc:"Mean value of samples in period." },
	 }
      }

      /*
      number: {
        vars: {
	  value: { type:numeric,  value:0.0,  doc:"Input and output value."},
	  store: { type:numeric,  value:0.0,  doc:"Store but don't emit until the next exec."}
	}
      }
      */

      number: {
        doc:[ "Number box",
	"By default the type of the output is the type of the first input variable.",
	"However, an explicit type may be set using the 'out_type' argument." ]
	
        vars: {
	  in:       { type:numeric,  value:0.0,    flags:["notify","mult"], doc:"Set the current value."},
	  trigger:  { type:all,      value:0.0,    flags:["notify"],        doc:"Send the currrent value on the next exec cycle."},
	  out_type: { type:string,   value:"",     flags:["init"],          doc:"The type of the output value."},
	  out:      { type:runtime,                flags:["no_src"],        doc:"Output numeric value."},
	}
      }

      string_list: {
         doc: ["List of strings with a drop-down menu interface."],
	 vars: {
	   list: { type:cfg,   flags:["init"],   value:{}                    doc:"List as a 'cfg' object." },
	   in:   { type:uint,  flags:["notify"], value:0,   ui:{ type:list}, doc:"Index of the string to output."},
	   out:  { type:string,                  value:"",                   doc:"Output string."},	   
	 }
      }

      on_start:{
        vars: {
	  out: { type:all, value:false, doc:"Emits 'true' on cycle 0."},
	}
      }
      
      halt:{
        vars: {
	  in: { type:all, value:0.0, flags:["src","notify"], doc:"Any value halts the network."},
	}
      }


      // 'reg' maintains a copy of the last value received on either 'in' or 'store'.
      // When the value changes 'out' will emit the new value on the next execution cycle.
      // The data type of 'out' is determined by the data type of 'in'.
      // The data type of 'store' must be convertable to the data type of 'out'.
      reg: {
        vars: {
	  in:    { type:all,      flags:["notify","src"],    doc:"Input value."},	  
	  store: { type:all,      flags:["notify"],          doc:"Alternate input value."},
	  out:   { type:runtime,  flags:["notify","no_src"], doc:"Output value."},
	}
      }
      
      timer: {
        vars: {
	  srate:     { type:srate, value:0,   flags:["src"],    doc:"Sample rate to use as the time base. 0=Use default system sample rate." },
	  delay_ms:  { type:ftime, value:0,   flags:["notify"], doc:"Delay before the first output." },
	  period_ms: { type:ftime, value:100, flags:["notify"], doc:"Timer period in milliseconds." },
	  out:       { type:bool,  value:false,                 doc:"Output pulse." },	  
	}
      }

      counter: {
        vars: {
	  trigger:	{ type:all,      flags:["notify","src"],	   doc:"Counter increments with each toggle of trigger." },
	  reset:	{ type:all,      flags:["notify"], value:0.0,	   doc:"Reset the counter to the initial value." },
	  init:		{ type:numeric,                    value:0.0,	   doc:"Counter initial value." },
	  min:		{ type:numeric,                    value:0.0,	   doc:"Minimum output value." },
	  max:		{ type:numeric,                    value:10.0,	   doc:"Maximum output value." },
	  inc:		{ type:numeric,                    value:1.0,	   doc:"Incrment value." },
	  repeat_fl:	{ type:bool,                       value:true,	   doc:"Repeat on reaching the limits." },
	  mode:	        { type:string,  flags:["notify"],  value:"modulo", doc:"limit mode: 'modulo'=wrap, 'reverse'=count in opposite direction, 'clip'=repeat limit value."},
	  out_type:     { type:string,  flags:["init"],    value:double,   doc:"The type of the output value." },
	  upr_lim:      { type:bool,    flags:["no_src"],  value:false,    doc:"Outputs 'true' if the  upper limit is reached." },
	  lwr_lim:      { type:bool,    flags:["no_src"],  value:false,    doc:"Outputs 'true' if the lower limit is reached." },
	  limit:        { type:bool,    flags:["no_src"],  value:false,    doc:"Outputs 'true' if the upper or lower limit is reached." },
	  out:		{ type:runtime,                    value:0.0,	   doc:"Counter output value."}, 
	}
      }

      // All elements of the list must belong to the same of three possible types:
      // string,cfg,numeric (uint,int,float,double)
      list: {
        vars: {
	  cfg_fname: { type:string, flags:["init"],  value:"", doc:"List cfg file." },
	  in:        { type:uint,   flags:["notify","src"],    doc:"List selection index." },
	  list:      { type:cfg,     flags:["init"], value:{}  doc:"List as a 'cfg' object." },
	  out:       { type:runtime,                           doc:"List output value." },
	  value:     { type:runtime, flags:["mult"],           doc:"List 'mult' output per list value." },
	}
      }
      
      add: {
        vars: {
	  in:    { type:numeric,               flags:["notify","src","mult"], doc:"Operands" },
	  otype: { type:string,  value:double, flags:["init"],       doc:"The type of the output value." },
	  out:   { type:runtime,               flags:["no_src"],     doc:"Result" },
	}
      }

      preset: {
      	vars: {
	  in: { type:string, flags:["src","notify"], doc:"Preset to select." },
	  }
      }
      
      
      xfade_ctl: {
      
        poly_limit_cnt: 1,

	// Notes:
	// 1. It would be better to setup the source net-proc as a 'in' variable with type 'net'.
	// 2. The only purpose for the 'srateSrc' is to get the sample rate of the system.
	
        vars: {
	   net:       { type:string,                  doc:"Proc name of the poly network."},
	   netSfxId:  { type:uint,  value: 0,         doc:"Label sfx id of the source poly instance."},
	   srateSrc:  { type:audio, flags:["src"],    doc:"Audio source to derive the sample rate."},
	   durMs:     { type:uint, value:1000,        doc:"Cross-fade duration in milliseconds" },
	   trigger:   { type:all,   flags:["notify"], doc:"Start cross-fade." },
	   preset:    { type:string,flags:["notify"], doc:"Preset to apply to the poly network." },
	   
	   gain: { type:coeff, flags:["mult"], value:0, doc:"Cross-fade gain output." }
	}
      },


      midi_voice: {
        vars: {
	  in:    { type:midi,                 doc:"MIDI in" },
	  gain:  { type:coeff, value:1.0,     doc:"Audio gain." },
	  chCnt: { type:uint, flags:["init"],  doc:"Output audio channel count."},
	  out:   { type:audio,                doc:"Audio out" },
	  print_fl: { type:bool, value:false, doc:"Print MIDI message to console." },
	  done_fl: { type:bool, value:false,  doc:"Triggers when voice is available."}
	}
      },

      poly_voice_ctl: {
      
        poly_limit_cnt: 1,

        vars: {
		   
	   in:        { type:record, fmt:{ alloc_cnt:1024, required:["midi"]}    doc:"MIDI input."},
	   voice_cnt: { type:uint, value:10,     flags:["init"],  doc:"Count of voices." },
	   prune_thresh: { type:uint, value: 5,                  doc:"Begin stopping voices if more than this count of voices is active." },
	   out:       { type:midi,              flags:["mult"],  doc:"MIDI output to voices. One per voice." },
	   gate_fl:   { type:bool,              flags:["mult"],  doc:"Output: Per voice. Goes true with note-on, false when done_fl is set." },
	   done_fl:   { type:bool, value:false, flags:["mult"],  doc:"Input: Voice available feedback triggers from voices. One per voice."},
	   reset:     { type:all, flags:["notify"], value:false, doc:"Reset all voices." }
	   
	}
      },

      piano_voice: {
        vars: {
	  wtb_fname: { type:string, flags:["init"], doc:"Wave table bank cfg. file." },
	  wtb_instr: { type:string, value:"piano", flags:["init"], doc:"Instrument label of the selected wave-table bank."},
	  in:        { type:midi,   doc:"MIDI in" },
	  out:       { type:audio,  doc:"Audio out" },
	  done_fl:   { type:bool, value:false,  doc:"Output: True when voice is available, false when active."},
	  gate_fl:   { type:bool, value:false,  doc:"Output: True when voice is active, false when inactive." },
	  rls_coeff: { type:coeff, value:0.9, doc:"Release decay factor. Increase for longer decays."},
	  rls_thresh:{ type:coeff, value:0.01,doc:"Note off threshold. Decrease for longer decays."},
	  
	  test_pitch:      { type:uint, value:0, doc:"Pitch to test." },
	  test_key_pitch:  { type:uint, value:48, doc:"Base pitch to use for lowest velocity when in 'test' mode." },
	  
	  load_thread_cnt: { type:uint, flags:["init"], value:16,  doc:"Count of threads to use for wave table loading." }
	}
      },

      voice_detector: {
        vars: {
	  in:         { type:audio,                               doc:"Audio in" },
	  enable_fl:  { type:bool,  flags:[notify], value:false,  doc:"Set when this voice detector is enabled." },
	  rls_thresh: { type:coeff, flags:[notify], value:0.01,   doc:"Voice off threshold." },
	  done_fl:    { type:bool,                    value:true, doc:"Output: Set when the voice is inactive, cleared when it is active."}
        }
      },


      print: {
      	 vars: {
	   in:     { type:all, flags:["mult"],   doc: "Value to print." },
	   eol_fl: { type:all, flags:["notify"], doc: "Trigger an end-of-line." },
	   text:   { type:cfg, flags:["notify"], doc: "List of labels." },
	 }
      }

      midi_msg: {
        vars: {
	  ch:      { type:uint, flags:["notify"], value:0, doc:"MIDI channel input." },
	  status:  { type:uint, flags:["notify"], value:0, doc:"MIDI status input."},
	  d0:      { type:uint, flags:["notify"], value:0, doc:"MIDI data byte 0."},
	  d1:      { type:uint, flags:["notify"], value:0, doc:"MIDI data byte 1."},
	  trigger: { type:all,  flags:["notify"], value:0, doc:"Send message."},
	  buf_cnt: { type:uint,                   value:16, flags:["init"], doc:"Length of internal msg buffer."},
	  out:     { type:midi,                                             doc:"MIDI output."},
	}
      }

      midi_split: {
        vars: {
	  in:     { type:midi, doc:"MIDI in" },
	  ch:     { type:uint, value:0, doc:"MIDI channel output" },
	  status: { type:uint, value:0, doc:"MIDI status output" },
	  d0:     { type:uint, value:0, doc:"MIDI data byte 0."},
	  d1:     { type:uint, value:0, doc:"MIDI data byte 1."},
	  buf_cnt: { type:uint,  value:16, flags:["init"], doc:"Length of internal msg buffer."}
	}
      }

      midi_file: {
        doc: [ "MIDI file player",
	       "CSV file format: 'uid','tpQN','bpm','dticks','ch','status','d0','d1'",
	       "tpQN = ticks per quarter note should be given on the first line. (Defaults to 1260).",
	       "bpm  = beats per minute should be given on the first line. (Defaults to 60)." ]
	       
        vars: {
	  fname:         { type:string, flags:["notify"],   value:"",    doc:"MIDI file name." },
	  csv_fname:     { type:string, flags:["notify"],   value:"",    doc:"MIDI CSV fname. See: midi::file open_csv()." },
	  alt_csv_fname: { type:string, flags:["notify"],   value:"",    doc:"MIDI CSV fname. See: midi::file open_csv_2()." },
	  start:         { type:all,    flags:["notify"], value:false, doc:"Start playback from the start of the file. Set to True to start playing immediately." },
	  stop:          { type:all,    flags:["notify"], value:false, doc:"Stop playback" },
	  done_fl:       { type:bool,                     value:false, doc:"Emits true on done." },
	  out:           { type:midi,                                  doc:"MIDI output."},
	  r_out:        { type:record,                                 doc:"MIDI output as records.",
	                  fmt: {
			    alloc_cnt:1024,
			    fields: {
			      midi: { type:m3,             doc:"MIDI channel event message" },
			    }
			  }
			}

	  
	}
      }


      recd_route: {
        doc:[ "Route incoming records to a specific output variable based on the 'select' value ",
	"or on the record field indicated by 'sel_field'",
	
	]
	vars: {
	  out_cnt:     { type:uint,   flags:["init"], value:2,        doc:"Count of output variables." },
	  sel_field:   { type:string, flags:["init"], value:"select", doc:"Field name containing the name of the record field used to supply  the 'select' integer."},
	  select:      { type:uint,   value:-1,                       doc:"Set to select the output variable. -1=No select. range:0 to <out_cnt>" },
	  in:          { type:record,                                 doc:"Input records" },
	  out:         { type:record, flags:["mult"],                 doc:"Output records" },
	  recd_buf_cnt:{ type:uint, flags:["init"], value:1024,  doc:"Size of output record buffers."},

	}
      }

      midi_merge: {
        doc: [ "MIDI merger."],
	vars: {	  
	  buf_cnt:   { type:uint,   flags:["init"], value:64, doc:"MIDI message buffer count." },
	  in:        { type:midi,   flags:["mult"],           doc:"MIDI input port."},
	  out:       { type:midi,                             doc:"MIDI output port."}
	}
      }

 
      poly_xform_ctl: {
        doc: ["On 'trigger' mix and route all incoming audio to the next available output channel  "],
        vars: {
	   out_ch_cnt:{ type:uint,  flags:["init"],           doc:"Count of audio output channels."},
	   in:        { type:audio, flags:["src","mult"],     doc:"Audio input." },
	   midi:      { type:midi,  flags:["mult"],           doc:"Per audio channel MIDI message from poly_voice_ctl." },
	   donefl:    { type:bool,  flags:["mult"],           doc:"Per audio channel voice 'available' flags." },
	   trig:      { type:all,   flags:["notify"],         doc:"Trigger to advance to next channel."},
	   out_ch_idx:{ type:uint,  value:0,                  doc:"Transform preset id. Change indicates that successive notes should go to a new output." },
	   out:       { type:audio, flags:["mult"]            doc:"Audio output."},
	}
      }


      gutim_ps_msg_table: {
        doc:[ "Score location controlled message table."],
	vars: {
	  in:          { type:record, flags:["notify"], fmt:{ required:["loc"] },       doc:"Input record with 'loc' field." },
	  sel_id:      { type:uint,   flags:["notify"], value:0,      doc:"Activate a 'cfg' with the given id."},
	  fname:       { type:string, flags:["notify"], value: "",    doc:"Cfg. file containing the message table."},
	  cfg:         { type:cfg,    flags:["notify"], value:{},     doc:"Cfg. record containing the message table."},
	  pri_prob_fl:        { type:bool,                     value: false, doc:"See gutim_ps pri_prob_fl." },
	  pri_uniform_fl:     { type:bool,                     value: false, doc:"See gutim_ps pri_uniform_fl." },
	  pri_dry_on_play_fl: { type:bool,                     value: false, doc:"See gutim_ps pri_dry_on_play_fl." },
	  pri_allow_all_fl:   { type:bool,                     value: false, doc:"See gutim_ps pri_allow_all_fl." },
	  per_note_fl:        { type:bool,                     value: false, doc:"See gutim_ps per_note_fl." },
	  heat:               { type:coeff,                    value: 1.0f,  doc:"Process chain input gain setting."},
        }
      }

      gutim_take_menu: {
          doc:[ "GUTIM take menu."],
	  vars: {
            index:       { type:uint,   flags:["notify"], value:0, ui:{ type:list }, doc:"Selection index"},
	    cfg_fname:   { type:string, flags:["init"], value: "",    doc:"Cfg. file containing the message table."},
	    cfg:         { type:cfg,    flags:["init"], value:{},     doc:"Cfg. record containing the message table."},
	    take_id:     { type:uint,                   value:0,      doc:"Numeric take id."},
	    beg_loc:     { type:uint,                   value:0,      doc:"Take begin location."},
	    end_loc:     { type:uint,                   value:0,      doc:"Take end location."},
	    fname:       { type:string,                 value:"",     doc:"Take filename."},
	 }
      }

      /*
      score_player_ctl :
      {
	doc:[ "Automate the score follower by sending beg/end locations and start commands based on an integer map." ]
	vars: {	}
      }
*/

      score_player: {
        doc: [ "Generate MIDI and score location information from a score file." ]
	vars: {
	  fname:   { type:string, flags:["init"],   value:"",    doc:"Score file name." },
	  stopping_ms: { type:uint, flags:["init"], value:5000,  doc:"Maximum stopping time in milliseconds." },
	  start:   { type:all,    flags:["notify"], value:false, doc:"Start playback" },
	  stop:    { type:all,    flags:["notify"], value:false, doc:"Stop playback" },
	  b_loc:   { type:uint,   flags:["notify"], value:0,     doc:"Score begin location." },
	  e_loc:   { type:uint,   flags:["notify"], value:0,     doc:"Score end location." },
	  b_meas:  { type:uint,   flags:["notify"], value:0,     doc:"Score begin measure." },
	  e_meas:  { type:uint,   flags:["notify"], value:0,     doc:"Score end measure." },
	  done_fl: { type:bool,                     value:false, doc:"Emits true on done." },
	  loc_cnt: { type:uint,                     value:0,     doc:"Output: Value of max 'loc'."},
	  out:     { type:record,                                doc:"Score event record.",
	                  fmt: {
			    fields: {
			      midi: { type:m3,             doc:"MIDI channel event message" },
			      loc:  { type:uint, value:-1, doc:"Score location id." },
			      meas: { type:uint, value:-1, doc:"Score measure." },
			      piano_id:{ type:uint, value:-1, doc:"Piano id." }
			    }
			  }
			}
	  }
	},
      
      vel_table: {
        doc:[ "Remap MIDI velocity values."
	      "If the incoming record has a 'score_vel' field then this is taken as the source velocity to be mapped and the MIDI message velocity is ignored."
	    ]
	vars: {
	  vel_tbl_fname:{ type:string, flags:["init"], value:"",    doc:"Velocity table filename as create by vwVelTableTuner." },
	  vel_tbl_label:{ type:string, flags:["init"], value:"",    doc:"Name of the active velocity table referenced by 'vel_fname'."},
	  in: { type:record, fmt:{ required:["midi"]},              doc:"Record with 'midi' field."},
	  out:{ type:record, doc:"Same as input record with midi velocity remapped according the velocity table."
	      fmt: { alloc_cnt:1024, fields: { midi: { type:m3, doc:"MIDI channel event message" } }}
	      
	  }
	  recdbufN: { type:uint, flags:["init"], value:128, doc:"Internal record buffer size."}
	}
      }
      
      score_follower: {
        doc:[ "MIDI score follower: Sets the 'loc' field of the output record according to the score location." ]
	vars: {
	  in:		 { type:record,                              doc:"Input record with 'midi' and 'loc' fields." },
	  dyntbl_fname:  { type:string, flags:["init"], value:"",    doc:"Dynamics reference table file name." },
	  score_fname:	 { type:string, flags:["init"], value:"",    doc:"Score file with location information." },
	  score_wnd:	 { type:uint,   flags:["init"], value:7,     doc:"Count of locations in the score search window." },
	  midi_wnd:	 { type:uint,   flags:["init"], value:15,    doc:"Count of MIDI events to align in the score search window." },
	  print_fl:	 { type:bool,   flags:["init"], value:false, doc:"Set to print log of score follower state." },
	  back_track_fl: { type:bool,   flags:["init"], value:false, doc:"Set if the score follower is allowed to report locations out of order." },
	  loc:		 { type:uint,                                doc:"Score location." },
	  out:		 { type:record,                              doc:"Input record with the 'loc' field set ." }
	}	
      }

      score_follower_2: {
        doc:[ "MIDI score follower: Sets the 'loc' field of the output record according to the score location." ]
	vars: {
	  in:		 { type:record, fmt:{ required:["midi"]}       doc:"Input record with 'midi' field." },
	  score_fname:	 { type:string, flags:["init"],   value:"",    doc:"Score file with location information." },
	  b_loc:         { type:uint,                     value:0,     doc:"Score begin location." },
	  e_loc:         { type:uint,                     value:0,     doc:"Score end location." },	  
	  reset_trigger: { type:all,    flags:["notify"], value:false, doc:"Reset the score follower." },
	  loc_cnt:       { type:uint,   flags:["init"],   value:0,     doc:"Maximum location id." },
	  print_fl:	 { type:bool,   flags:["init"],   value:false, doc:"Set to print log of score follower state." },
	  out:{ type:record,  doc:"Pass-through of incoming MIDI with score location and score velocity.",
	      fmt: {
	            alloc_cnt:1024,  // internal recd_array size 
	            fields: {
		      loc:  { type:uint, value:-1, doc:"Score location id or if score track failed." },
		      meas: { type:uint, value:-1, doc:"Score measure associated with 'loc'." },
		      score_vel: { type:uint, value:-1, doc:"Score mapped velocity or -1 if 'loc' is -1." } 
		      }	      
	     }           		  
           }
	 }	
      }

      preset_select: {
        doc:[ "Given a score location emit a preset label."],
	vars: {
	  cfg:         { type:cfg,    flags:["init"],                doc:"Initial preset configuration." },
	  in:          { type:record, fmt:{ required:["loc"]}        doc:"Input record with 'loc' field." },
	  fname:       { type:string, flags:["init"], value:"",      doc:"Preset file name."},
	  loc:         { type:uint,   value:0,                       doc:"Seek to this location." },
	  
	  //out_idx:      { type:uint,   value:0,                    doc:"Transform output index." },
	  preset_label: { type:string, value:"",                     doc:"Preset label to apply." }
	}

        presets: {
	  init: {
	      cfg: {
	        preset_labelL: [ "dry", "a", "b", "c", "d", "f1", "f2", "f3", "f4", "g", "ga", "g1a", "g1d" ],

		alt_labelL: [ "A","B","C","D","E","F","G" ],

		default_gain:           1.0,
		default_wet_dry_gain:   0.5,
		default_fade_ms:       50.0,
 		default_preset:       "dry",

		default_master_wet_in_gain:   1.0,
	      	default_master_wet_out_gain:  1.0,
	        default_master_dry_gain:      1.0,
	        default_master_sync_delay_ms: 400,  // spirio 400
	      },


	     
	  }
	}

     }

      gutim_ps: {
        doc:[ "Given score location and MIDI note messages emit transform parameters."],
	vars: {
	  cfg:            { type:cfg,    flags:["init"],                doc:"Initial preset configuration." },
	  fname:          { type:string, flags:["init"], value:"",      doc:"Preset file name."},
	  loc_cnt:        { type:uint,   flags:["init"], value:0,       doc:"Count of uniq 'loc' id's in the score."},
	  //in:             { type:record, fmt:{ required:["loc"] },      doc:"Input record with 'loc' field." },
	  in:             { type:record,   doc:"Input record with 'loc' field." },
	  loc:            { type:uint,                     value:0,     doc:"Seek to this location." },
	  reset:          { type:bool,   flags:["notify"], value:false, doc:"Reset to initial state."},
	  pri_manual_sel: { type:uint,   flags:["notify"], value:-1,    doc:"Manually select the presets.", ui:{ type:list}  },
	  sec_manual_sel: { type:uint,   flags:["notify"], value:-1,    doc:"Manually select the presets.", ui:{ type:list}  },
	  per_note_fl:    { type:bool,                     value:false, doc:"Change the preset on every note, otherwise change on new preset 'fragments'." },
	  per_loc_fl:     { type:bool,                     value:false, doc:"Change the preset on every score location, change according to 'per_note_fl'." },
	  dry_chord_fl:   { type:bool,                     value:false, doc:"Set to make 50% of all chord notes dry."},

	  pri_prob_fl:        { type:bool,  flags:["notify"],     value: false, doc:"Select primary preset probabilstically." }
	  pri_uniform_fl:     { type:bool,  flags:["notify","ui_disable"], value: false, doc:"Use a uniform probability distribution rather than an 'order' weighted distribution." },
	  pri_dry_on_play_fl: { type: bool, flags:["notify","ui_disable"], value: true,  doc:"Select 'dry' if it is the manually selected preset." },
	  pri_allow_all_fl:   { type: bool, flags:["notify","ui_disable"], value: false, doc:"Select from all possible presets rather than the presets with 'order' > 0." },
	  pri_dry_on_sel_fl:  { type: bool, flags:["notify","ui_disable"], value: true,  doc:"Select 'dry' if 'allow_all' is selected and 'dry' has 'order' > 0." },

	  interp_fl:          { type: bool,  flags:["notify"],     value: false, doc:"Interpolate between the primary and secondary presets." },
	  interp_dist:        { type: float, flags:["notify","ui_disable"], value: 0.5,   doc:"Unit fractionaly distance between primary and secondary preset." },
	  interp_rand_fl:     { type: bool,  flags:["notify","ui_disable"], value: true,  doc:"Randomly select the distance between the primary and secondary preset." },

	  sec_prob_fl:        { type:bool,  flags:["notify","ui_disable"], value: false, doc:"Select secondary preset probabilstically." }
	  sec_uniform_fl:     { type:bool,  flags:["notify","ui_disable"], value: false, doc:"Use a uniform probability distribution rather than an 'order' weighted distribution." },
	  sec_dry_on_play_fl: { type: bool, flags:["notify","ui_disable"], value: true,  doc:"Select 'dry' if it is the manually selected preset." },
	  sec_allow_all_fl:   { type: bool, flags:["notify","ui_disable"], value: false, doc:"Select from all possible presets rather than the presets with 'order' > 0." },
	  sec_dry_on_sel_fl:  { type: bool, flags:["notify","ui_disable"], value: true,  doc:"Select 'dry' if 'allow_all' is selected and 'dry' has 'order' > 0." },
	  

	  midi_in:     { type:midi,              flags:["mult","no_ui"], doc:"Per voice MIDI in" },
	  wnd_smp_cnt: { type:uint,  value:512,  flags:["mult","no_ui"], doc:"PVA window sample count" },
	  ceiling:     { type:coeff, value:20,   flags:["mult","no_ui"], doc:"SD ceiling parameter" },
	  expo:        { type:coeff, value:2.0,  flags:["mult","no_ui"], doc:"SD expo parameter" },
	  thresh:      { type:coeff, value:70.0, flags:["mult","no_ui"], doc:"SD thresh parameter" },
	  upr:         { type:coeff, value:0.0,  flags:["mult","no_ui"], doc:"SD upr parameter" },
	  lwr:         { type:coeff, value:2.0,  flags:["mult","no_ui"], doc:"SD lwr parameter" },
	  mix:         { type:coeff, value:0.0,  flags:["mult","no_ui"], doc:"SD mix parameter" },
	  c_igain:     { type:coeff, value:1.0,  flags:["mult","no_ui"], doc:"Compressor igain parameter" },
	  c_ogain:     { type:coeff, value:1.0,  flags:["mult","no_ui"], doc:"Compressor ogain paramter" },
	  dry_gain:    { type:coeff, value:1.0,  flags:["mult","no_ui"], doc:"Output gain." },
	}


        presets: {
	  dry:   { dry_gain:0 },
	  a:     { dry_gain:1.0 },
	  b:     { dry_gain:1.0 },
	  c:     { dry_gain:1.0 },
	  d:     { dry_gain:1.0 },
	  f_1:   { dry_gain:1.0 },
	  f_2:   { dry_gain:1.0 },
	  f_3:   { dry_gain:1.0 },
	  f_4:   { dry_gain:1.0 },
	  g:     { dry_gain:1.0 },
	  g_a:   { dry_gain:1.0 },
	  g_1_a: { dry_gain:1.0 },
	  g_1_d: { dry_gain:1.0 },
	  
	  init: {
	      cfg: {
	        preset_labelL: [ "dry", "a", "b", "c", "d", "f1", "f2", "f3", "f4", "g", "ga", "g1a", "g1d" ],

		alt_labelL: [ "A","B","C","D","E","F","G" ],

		default_gain:           1.0,
		default_wet_dry_gain:   0.5,
		default_fade_ms:       50.0,
 		default_preset:       "dry",

		default_master_wet_in_gain:   1.0,
	      	default_master_wet_out_gain:  1.0,
	        default_master_dry_gain:      1.0,
	        default_master_sync_delay_ms: 400,  // spirio 400
	      },


	     
	  }
	}
      },


}
