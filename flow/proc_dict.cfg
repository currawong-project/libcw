{
      balance: {
        doc: [ "Stereo balance control." ]
        vars: {
	   in:      { type:coeff, value:0.5, doc:"Input vaue" },
	   out:     { type:coeff, doc:"Ouput value. Same as input value."},
	   inv_out: { type:coeff, doc:"1.0 minus output value."}
	}
      }

      midi_in: {
        doc: [ "MIDI input device."],
	vars: {
	  dev_label: { type:string, value:"<all>", doc:"MIDI input device label. Set to '<all>' to accept input from any device."},
	  port_label:{ type:string, value:"<all>", doc:"MIDI input device port label. Set to '<all>' to accept input from any device."},
	  out:       { type:midi,   doc:"MIDI input port." },
	}
      }
      
      midi_out: {
        doc: [ "MIDI output device."],
	vars: {	  
	  dev_label: { type:string,                 doc:"MIDI output device label."},
	  port_label:{ type:string,                 doc:"MIDI output device port label."},
	  buf_cnt:   { type:uint,   flags:["init"], value:64, doc:"MIDI message buffer count." },
	  in:        { type:midi,                   doc:"MIDI output port."}
	}
      }

      audio_in: {
        doc: [ "Audio input device." ],
        vars: {
	  dev_label: { type:string,  doc:"Audio device label." },
          out:       { type:audio,   doc:"Audio output" },
          }
      }

      audio_out: {
        doc: [ "Audio output device." ],
        vars: {
          dev_label: { type:string,               doc:"Audio device label." },
          in:        { type:audio, flags:["src"], doc:"Audio input." }
          }
      }
      
      audio_file_in: {
        vars: {
          fname: {   type:string, doc:"Audio file name." },
          out:{      type:audio,  doc:"Audio file output" },
	  on_off:{   type:bool, value:false, doc:"1=on 0=off" },,
	  seekSecs:{ type:ftime, value:0.0, doc:"Seek to the specified seconds offset." } 
          eofFl:{     type:bool,  value: true, doc:"Set the system 'halt' flag when the audio is completely read."},
          }
      }

      audio_file_out: {
        vars: {
          fname: { type:string,               doc:"Audio file name." },
	  bits:  { type:uint, value:32u,      doc:"Audio file word width. (8,16,24,32,0=float32)."},
          in:    { type:audio, flags:["src"], doc:"Audio file input." }
          }
      }

      audio_gain: {
        vars: {
	   in:   { type:audio, flags:["src"], doc:"Audio input." },
	   gain: { type:coeff, value:1.0, doc:"Gain coefficient." }
	   out:  { type:audio,             doc:"Audio output." },
        }
      }

      audio_split: {
         vars: {
	   in:     { type:audio, flags:["src"],            doc:"Audio input." },
	   select: { type:cfg,   flags:["init"],           doc:"A list of integers where each value selects an output channel for the associated input channel." }
	   igain:  { type:coeff, value:1.0,                doc:"Audio gain for each input channel." }
	   ogain:  { type:coeff, flags["mult"], value:1.0, doc:"Audio gain for each output channel." }
	   out:    { type:audio, flags["mult"],            doc:"Audio output." },
	 }

        presets:
	{
	   mute_off: { gain:1   },
	   mute_on:  { gain:0 },
	}
      }


      audio_duplicate: {
         vars: {
	   in:        { type:audio, flags:["src"], doc:"Audio input."},
	   duplicate: { type: uint,            doc:"Count of times to repeat this channel." },
	   gain:      { type: coeff, value:1.0, doc:"Audio gain." },
	   out:       { type:audio,             doc:"Audio output containing repeat * input channel count channels."}
	 }
      }

     audio_merge: {     
        vars: {
	  in:       { type:audio,            flags:["src", "mult"], doc:"Audio input channel." },
	  gain:     { type:coeff,  value: 1, flags:["src", "mult"], doc:"Input channel gain." },
	  out_gain: { type:coeff,  value: 1,                        doc:"Output gain" },
          out:      { type:audio,                                   doc:"Audio output. Channel count is the sum of the input channel count." },	
	}
      }

      audio_mix: {
         vars: {
	   in:    { type:audio, flags:["src","mult"],       doc:"Audio input." },
	   igain: { type:coeff, flags:["mult"], value:0.5,  doc:"Audio gain for input 0." },
	   ogain: { type:coeff,                 value:1.0,  doc:"Output gain." },
	   out:   { type:audio,                             doc:"Audio output. Channel count is max of the input signal channels." },
	 }
      }

      audio_marker: {
        vars: {
	  in:      { type:audio, flags:["src"], doc:"Audio input."},
	  trigger: { type:all,   value:0,       doc:"Marker trigger."},
	  out:     { type:audio,                doc:"Audio output."},
	}
      }

      audio_delay: {
        vars: {
	   in:         { type:audio, flags:["src"],   doc:"Audio input." },
	   maxDelayMs: { type:ftime, value:1000.0   doc:"Maximum possible delay in milliseconds." },
	   delayMs:    { type:ftime,                doc:"Delay in milliseconds." },
	   out:        { type:audio,               doc:"Audio output." },
	}
      }

      audio_silence: {
        vars: {
      	  srate: { type:srate,  value:0, flags:["init"], doc:"Signal sample rate. 0=Use default system sample rate"},
	  ch_cnt: { type:uint,   value:1, flags:["init"], doc:"Count of output audio channels. (e.g. 1=mono, 2=stereo, ...)"},
	  out:   { type:audio,                           doc:"Audio signal containing only 0."},
        }
      }


      sine_tone: {
        vars: {
	  srate:     { type:srate, value:0,       doc:"Sine tone sample rate. 0=Use default system sample rate"}
	  ch_cnt:    { type:uint,  value:2,       doc:"Output signal channel count."},
	  hz:        { type:coeff, value:440.0,   doc:"Frequency in Hertz."},
	  phase:     { type:coeff, value:0.0,     doc:"Offset phase in radians."},
	  dc:        { type:coeff, value:0.0,     doc:"DC offset applied after gain."},
	  gain:      { type:coeff, value:0.8,     doc:"Signal frequency."},	  
          out:       { type:audio,                doc:"Audio output" },
          }

	presets: {
	  a220 : { hz:220 },
	  a440 : { hz:440 },
	  a880 : { hz:880 },
          mono:  { ch_cnt:1, gain:0.75 }
	}
      }

      pv_analysis: {
        vars: {
          in:		{ type:audio,    flags:["src"],   doc:"Audio input." },
	  maxWndSmpN:	{ type:uint,     value: 512,  doc:"Maximum window sample count." },
          wndSmpN:	{ type:uint,     value: 512,  doc:"Window sample count." },
          hopSmpN:	{ type:uint,     value:  128,  doc:"Hop sample count." },
          hzFl:		{ type:bool,     value: false, doc:"Calculate frequency via the method of phase changeof each bin." },
          out:		{ type:spectrum,               doc:"Spectrum output." }
          }

        presets: {

	  dry: {
	    wndSmpN:  512,
	    hopSmpN:  128	  
	  }

	  kc: {
	    wndSmpN:  512,
	    hopSmpN:  128
	  }
	  
          a: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }

          b: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }

          c: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }

          d: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }

          f_1: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }
	  
          f_2: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }

          f_3: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }

          f_4: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }

          g: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }
	  
          g_a: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }

          g_1_a: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }

          g_1_d: {
	    wndSmpN:  512,
	    hopSmpN:  128
          }	  
	}
      }

      pv_synthesis: {
        vars: {
          in:  { type:spectrum,  flags:["src"],  doc:"Spectrum input." },
          out: { type:audio,                  doc:"Audio output." }
          }
      }

      spec_dist: {
        vars: {
          in:       { type:spectrum, flags:["src"], doc:"Spectrum input." },

	  bypass:   { type:bool, value: false, doc:"Copy input to output without transform."},
          ceiling:  { type:coeff, value: 30.0, doc:"Ceiling parameter."},
          expo:     { type:coeff, value:  2.0, doc:"Exponent parameter."},
          thresh:   { type:coeff, value: 54.0, doc:"Threshold parameter."},
          upr:      { type:coeff, value: -0.7, doc:"Upper slope parameter."},
          lwr:      { type:coeff, value:  2.0, doc:"Lower slope  parameter."},
          mix:      { type:coeff, value:  0.0, doc:"Basic/Bump Mix parameter."},

          out:      { type:spectrum,          doc:"Spectrum output." },

          }
          
        presets: {

	  dry: {
	       
	  }

	  kc: {
	    ceiling:  20.0,
	    expo:      2.0,
	    thresh:   65.0,
	    upr:       0.0,
	    lwr:       2.0,
	    mix:       0.0
	  }
	  
          a: {
            ceiling:  20.0
            expo:     2.0
            thresh:   60.0
            upr:      [   -1.1, -0.99],
            lwr:      2.0
            mix:      0.0
          }

          b: {
            ceiling:  20.0
            expo:      2.0
            thresh:   [   77.0, 74.0 ], 
            upr:      -0.5
            lwr:      [    3.0,  2.0 ],
            mix:       0.0
          }

          c: {
            ceiling:  20.0
            expo:      2.0
            thresh:   80.0
            upr:      -0.5
            lwr:       5.0
            mix:       0.0
          }

          d: {
            ceiling:  20.0
            expo:      2.0
            thresh:   70.0
            upr:    [ -3.9, 04.5]
            lwr:       4.0
            mix:       0.0
          }

          f_1: {
            ceiling:  20.0
            expo:      2.0
            thresh:   50.0
            upr:      -3.0
            lwr:       1.0
            mix:       0.0
          }
	  
          f_2: {
            ceiling:  20.0
            expo:      2.0
            thresh:   60.0
            upr:      -3.0
            lwr:       1.0
            mix:       0.0
          }

          f_3: {
            ceiling:  20.0
            expo:      2.0
            thresh:   55.0
            upr:      -3.0
            lwr:       1.0
            mix:       0.0
          }

          f_4: {
            ceiling:  20.0
            expo:      2.0
            thresh:   55.0
            upr:      -5.0
            lwr:       1.0
            mix:       0.0
          }

          g: {
            ceiling:  40.0
            expo:      8.0
            thresh:   [60.0 64.0]
            upr:      -0.7
            lwr:       8.0
            mix:       1.0
          }
	  
          g_a: {
            ceiling:  40.0
            expo:      2.0
            thresh:   [50.0 54.0]
            upr:      -0.7
            lwr:       2.0
            mix:       1.0
          }

          g_1_a: {
            ceiling:  20.0
            expo:      2.0
            thresh:   [50.0 54.0]
            upr:      -0.7
            lwr:       8.0
            mix:       1.0
          }

          g_1_d: {
            ceiling:  [60.0 64.0]
            expo:     [ 7.0  5.0]
            thresh:   [40.0 34.0]
            upr:      [-0.4 -0.3]
            lwr:      [ 7.0  5.0]
            mix:        1.0
          }
	}  
      }
      

      compressor: {
        vars: {
          in:        { type:audio, flags:["src"]  true, doc:"Audio input." },	  
          bypass:    { type:bool, value:  false, doc:"Bypass the compressor."},
	  igain:     { type:coeff, value:    1.0, doc:"Input gain."},
	  thresh:    { type:coeff, value:   90.0, doc:"Attack threshold in dB."},
	  ratio:     { type:coeff, value:    2.0, doc:"Compression ratio."},
	  atk_ms:    { type:coeff, value:   20.0, doc:"Attack time in milliseconds."},
	  rls_ms:    { type:coeff, value:   20.0, doc:"Release time in milliseconds."},
	  wnd_ms:    { type:coeff, value:  200.0, doc:"RMS calc. window length in milliseconds."},
	  maxWnd_ms: { type:coeff, value: 1000.0, doc:"Maximim (allocated) window length in milliseconds."},
	  ogain:     { type:coeff, value:    1.0, doc:"Output gain."},	  
          out:       { type:audio,               doc:"Audio output." },	
	}
	
	presets: {
	  dflt: {
	     igain:   3.0
	     thresh: 60.0
	     ratio:   5.0
	     atk_ms:  5.0
	     rls_ms: 20.0
	     wnd_ms:100.0
	     ogain:   1.0
	  }
	  
	  kc: {
	     bypass:   false
	     igain:     3.0
	     thresh:   80.0
	     ratio:     2.0
	     atk_ms:   20.0
	     rls_ms: 1000.0
	     wnd_ms:  200.0
	     ogain:     1.0
	  }

	  input: {
              bypass: false
  	      igain:   2.0
	      thresh: 30.0
	      ratio:  12.0
	      atk_ms:  5.0
	      rls_ms: 20.0
	      wnd_ms: 20.0
	      ogain:   0.5	  
	  }

	  dry: {
	       
	  }

	   a: {
	     igain: 6.0
	     ogain: 1.0
	  }

	   b: {
	     igain: 10.0
	     ogain: 1.0
	  }

	   c: {
	     igain: 11.0
	     ogain: 1.0
	  }

	  d: {
	     igain: 9.0
	     ogain: 1.0
	  }

	  f_1: {
	     igain: 6.0
	     ogain: 1.0
	  }

	  f_2: {
	     igain: 6.0
	     ogain: 1.0
	  }

	  f_3: {
	     igain: 6.0
	     ogain: 1.0
	  }
	  
	  f_4: {
	     igain: 6.0
	     ogain: 1.0
	  }
	  
	  g: {
	     igain: 10.0
	     ogain: 0.75	
	  }
	  
	  g_a: {
	     igain: 10.0
	     ogain: 0.75
	  }

	  g_1_a: {
	     igain: 10.0
	     ogain: 0.75
	  }

	  g_1_d: {
	     igain: 10.0
	     ogain: 0.75
	  }


	}
      }

      limiter: {
        vars: {
          in:        { type:audio, flags:["src"]  true, doc:"Audio input." },	  
          bypass:    { type:bool, value:  false, doc:"Bypass the limiter."},
	  igain:     { type:coeff, value:    1.0, doc:"Input gain."},
	  thresh:    { type:coeff, value:    0.0, doc:"Linear (0.0-1.0) threshold."},
	  ogain:     { type:coeff, value:    1.0, doc:"Output gain."},	  
          out:       { type:audio,               doc:"Audio output." },	
	}
	
	presets: {
	    dflt: {
		bypass: false,
		igain:   1.0
		thresh:  0.9,
		ogain:   1.0
	  }

	}
      }

      dc_filter: {
        vars: {
          in:        { type:audio, flags:["src"], doc:"Audio input." },	  
          bypass:    { type:bool, value:  false, doc:"Bypass the DC filter."},
	  gain:      { type:coeff, value:    1.0, doc:"Output gain."},
          out:       { type:audio,               doc:"Audio output." },	
	}
	
	presets: {
	    dflt: {
		bypass: false,
		gain:   1.0
	  }

	}
      }

      audio_meter: {
        vars: {
	  in:      { type:audio, flags:["src"], doc:"Audio input." },
	  dbFl:    { type:bool, value: true, doc:"Output in Decibels." },
	  wndMs:   { type:ftime, value: 100.0, doc:"RMS window length." },
	  peakDb:  { type:coeff, value: -10.0, doc:"Peak threshold." },
	  out:     { type:coeff, value: 0.0,  doc:"Meter output." },
	  peakFl: { type:bool, value: false, doc:"Peak output." }
	  clipFl: { type:bool, value: false, doc:"Clip indicator output."},
	  rpt_ms: { type:uint, value:0, flags:["init"], doc:"Report period in ms or 0 for no report."},
	}
      }

      poly: {
        vars: {
	  count:        { type:uint, flags:["init"], value:1,     doc:"Count of network duplicates." },
	  parallel_fl:  { type:bool, flags:["init"], value:false, doc:"True to run voices concurrently." }
	}
      }

      sample_hold: {
         vars: {
	   in:        { type:audio, flags:["src"],  doc:"Audio input source." },
	   period_ms: { type:ftime,  value:50,       doc:"Sample period in milliseconds." },
	   out:       { type:sample,  value:0.0,      doc:"First value in the sample period." },
	   mean:      { type:sample,  value:0.0,      doc:"Mean value of samples in period." },
	 }
      }

      /*
      number: {
        vars: {
	  value: { type:numeric,  value:0.0,  doc:"Input and output value."},
	  store: { type:numeric,  value:0.0,  doc:"Store but don't emit until the next exec."}
	}
      }
      */

      number: {
        doc:[ "Number box",
	"By default the type of the output is the type of the first input variable.",
	"However, an explicit type may be set using the 'out_type' argument." ]
	
        vars: {
	  in:       { type:numeric,  value:0.0,    flags["mult"],    doc:"Set the current value."},
	  trigger:  { type:all,      value:0.0,                      doc:"Send the currrent value on the next exec cycle."},
	  out_type: { type:string,   value:"",     flags:["init"],   doc:"The type of the output value."},
	  out:      { type:runtime,                flags:["no_src"], doc:"Output numeric value."},
	}
      }

      halt:{
        vars: {
	  in: { type:all, value:0.0, flags:["src"], doc:"Any value halts the network."},
	}
      }


      // 'reg' maintains a copy of the last value received on either 'in' or 'store'.
      // When the value changes 'out' will emit the new value on the next execution cycle.
      // The data type of 'out' is determined by the data type of 'in'.
      // The data type of 'store' must be convertable to the data type of 'out'.
      reg: {
        vars: {
	  in:    { type:all,      flags:["src"],    doc:"Input value."},	  
	  store: { type:all,                        doc:"Alternate input value."},
	  out:   { type:runtime,  flags:["no_src"], doc:"Output value."},
	}
      }
      
      timer: {
        vars: {
	  srate:     { type:srate, value:0, flags["src"], doc:"Sample rate to use as the time base. 0=Use default system sample rate." },
	  delay_ms:  { type:ftime, value:0,  doc:"Delay before the first output." },
	  period_ms: { type:ftime, value:100, doc:"Timer period in milliseconds." },
	  out:       { type:bool, value:false, doc:"Output pulse." },	  
	}
      }

      counter: {
        vars: {
	  trigger:	{ type:all, flags["src"],	doc:"Counter increments with each toggle of trigger." },
	  reset:	{ type:all,       value:0.0,	doc:"Reset the counter to the initial value." },
	  init:		{ type:numeric,  value:0.0,	doc:"Counter initial value." },
	  min:		{ type:numeric,  value:0.0,	doc:"Minimum output value." },
	  max:		{ type:numeric,  value:10.0,	doc:"Maximum output value." },
	  inc:		{ type:numeric,  value:1.0,	doc:"Incrment value." },
	  repeat_fl:	{ type:bool,    value:true,	doc:"Repeat on reaching the limits." },
	  mode:	        { type:string,  value:"modulo",	doc:"limit mode: 'modulo'=wrap, 'reverse'=count in opposite direction, 'clip'=repeat limit value."},
	  out_type:     { type:string,  value:double, flags:["init"], doc:"The type of the output value." },
	  upr_lim:      { type:bool,    value:false,  flags:["no_src"], doc:"Outputs 'true' if the  upper limit is reached." },
	  lwr_lim:      { type:bool,    value:false,  flags:["no_src"], doc:"Outputs 'true' if the lower limit is reached." },
	  limit:        { type:bool,    value:false,  flags:["no_src"], doc:"Outputs 'true' if the upper or lower limit is reached." },
	  out:		{ type:runtime, value:0.0,	doc:"Counter output value."}, 
	}
      }

      // All elements of the list must belong to the same of three possible types:
      // string,cfg,numeric (uint,int,float,double)
      list: {
        vars: {
	  cfg_fname: { type:string, value:"",   flags:["init"],  doc:"List cfg file." },
	  in:        { type:uint, flags:["src"], doc:"List selection index." },
	  list:      { type:cfg,     value:{}  doc:"List as a 'cfg' object." },
	  out:       { type:runtime,             doc:"List output value." },
	  value:     { type:runtime, flags["mult"], doc:"List 'mult' output per list value." },
	}
      }
      
      add: {
        vars: {
	  in:    { type:numeric,               flags:["src","mult"], doc:"Operands" },
	  otype: { type:string,  value:double, flags:["init"],       doc:"The type of the output value." },
	  out:   { type:runtime,               flags:["no_src"],     doc:"Result" },
	}
      }

      preset: {
      	vars: {
	  in: { type:string, flags:["src"], doc:"Preset to select." },
	  }
      }
      
      
      xfade_ctl: {
      
        poly_limit_cnt: 1,

	// Notes:
	// 1. It would be better to setup the source net-proc as a 'in' variable with type 'net'.
	// 2. The only purpose for the 'srateSrc' is to get the sample rate of the system.
	
        vars: {
	   net:       { type:string,               doc:"Proc name of the poly network."},
	   netSfxId:  { type:uint,  value: 0,      doc:"Label sfx id of the source poly instance."},
	   srateSrc:  { type:audio, flags:["src"], doc:"Audio source to derive the sample rate."},
	   durMs:     { type:uint, value:1000,     doc:"Cross-fade duration in milliseconds" },
	   trigger:   { type:all,                  doc:"Start cross-fade." },
	   preset:    { type:string,               doc:"Preset to apply to the poly network." },
	   
	   gain: { type:coeff, flags:["mult"], value:0, doc:"Cross-fade gain output." }
	}
      },


      midi_voice: {
        vars: {
	  in:    { type:midi,  doc:"MIDI in" },
	  out:   { type:audio, doc:"Audio out" }
	  done_fl: { type:bool, value:false,  doc:"Triggers when voice is available."}
	}
      },

      poly_voice_ctl: {
      
        poly_limit_cnt: 1,

        vars: {
		   
	   in:        { type:midi,                              doc:"MIDI input."},
	   voice_cnt: { type:uint, value:3,     flags:["init"], doc:"Count of voices." },
	   out:       { type:midi,              flags:["mult"], doc:"MIDI output to voices. One per voice." },
	   done_fl:   { type:bool, value:false, flags:["mult"], doc:"Voice available feedback triggers from voices. One per voice."},
	   
	}
      },

      piano_voice: {
        vars: {
	  wtb_fname: { type:string, flags:["init"], doc:"Wave table bank cfg. file." },
	  wtb_instr:   { type:string, value:"piano", flags:["init"], doc:"Instrument label of the selected wave-table bank."},
	  in:      { type:midi,   doc:"MIDI in" },
	  out:     { type:audio,  doc:"Audio out" },
	  done_fl: { type:bool, value:false,  doc:"Triggers when voice is available."},
	  test_pitch: { type:uint, value:0, doc:"Pitch to test." },
	  test_key_pitch:  { type:uint, value:48, doc:"Base pitch to use for lowest velocity when in 'test' mode." },
	}
      },


      print: {
      	 vars: {
	   in:     { type:all, flags:["mult"], doc: "Value to print." },
	   eol_fl: { type:all,                 doc: "Trigger an end-of-line." },
	   text:   { type:cfg,                 doc: "List of labels." },
	 }
      }

      midi_msg: {
        vars: {
	  ch:      { type:uint, value:0, doc:"MIDI channel input." },
	  status:  { type:uint, value:0, doc:"MIDI status input."},
	  d0:      { type:uint, value:0, doc:"MIDI data byte 0."},
	  d1:      { type:uint, value:0, doc:"MIDI data byte 1."},
	  trigger: { type:all,   value:0, doc:"Send message."},
	  buf_cnt: { type:uint,  value:16, flags:["init"], doc:"Length of internal msg buffer."},
	  out:     { type:midi,  doc:"MIDI output."},
	}
      }

      midi_split: {
        vars: {
	  in:     { type:midi, doc:"MIDI in" },
	  ch:     { type:uint, value:0, doc:"MIDI channel output" },
	  status: { type:uint, value:0, doc:"MIDI status output" },
	  d0:     { type:uint, value:0, doc:"MIDI data byte 0."},
	  d1:     { type:uint, value:0, doc:"MIDI data byte 1."},
	  buf_cnt: { type:uint,  value:16, flags:["init"], doc:"Length of internal msg buffer."}
	}
      }

      midi_file: {
        doc: [ "MIDI file player",
	       "CSV file format: 'uid','tpQN','bpm','dticks','ch','status','d0','d1'",
	       "tpQN = ticks per quarter note should be given on the first line. (Defaults to 1260).",
	       "bpm  = beats per minute should be given on the first line. (Defaults to 60)." ]
	       
        vars: {
	  fname:     { type:string, flags:["init"], value:"",    doc:"MIDI file name." },
	  csv_fname: { type:string, flags:["init"], value:"",    doc:"MIDI CSV fname. See: midi::file open_csv()." },
	  done_fl:   { type:bool,                   value:false, doc:"Emits true on done." },
	  out:       { type:midi,                                doc:"MIDI output."}
	}
      }

      midi_merge: {
        doc: [ "MIDI merger."],
	vars: {	  
	  buf_cnt:   { type:uint,   flags:["init"], value:64, doc:"MIDI message buffer count." },
	  in:        { type:midi,   flags:["mult"],           doc:"MIDI input port."},
	  out:       { type:midi,                             doc:"MIDI output port."}
	}
      }


}
