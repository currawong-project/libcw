#include <gtest/gtest.h>

#include "cwCommon.h"
#include "cwLog.h"
#include "cwCommonImpl.h"
#include "cwTest.h"
#include "cwMem.h"
#include "cwFileSys.h"
#include "cwFile.h"
#include "cwText.h" // For textCompare, textLength

#include <string>
#include <vector>
#include <cstdio> // For remove()

using namespace cw;
using namespace cw::file;

// Helper function to create a temporary file with content
static rc_t createTempFile(const char* filename, const char* content, unsigned flags = kWriteFl, unsigned contentN=0) {
    handle_t h;
    rc_t rc = open(h, filename, flags);
    if (rc != kOkRC) return rc;
    rc = write(h, content, contentN==0 ? strlen(content) : contentN );
    if (rc != kOkRC) { close(h); return rc; }
    return close(h);
}


// Helper function to read file content into a std::string
static std::string readFileToString(const char* filename) {
    handle_t h;
    std::string content_str;
    if (open(h, filename, kReadFl | kBinaryFl) == kOkRC) {
        unsigned byte_count = byteCount(h);
        if (byte_count > 0) {
            std::vector<char> buf(byte_count + 1);
            if (read(h, buf.data(), byte_count) == kOkRC) {
                buf[byte_count] = '\0';
                content_str = buf.data();
            }
        }
        close(h);
    }
    return content_str;
}

// Fixture for file tests to manage temporary files
class FileTest : public ::testing::Test {
protected:
    void SetUp() override {
        test_filename = "test_temp_file.txt";
        test_binary_filename = "test_temp_binary.bin";
        test_copy_src = "test_copy_src.txt";
        test_copy_dst = "test_copy_dst.txt";
        test_backup_file = "test_backup.txt";
        test_backup_dir = "test_backup_dir";
    }

    void TearDown() override {
        remove(test_filename);
        remove(test_binary_filename);
        remove(test_copy_src);
        remove(test_copy_dst);
        remove(test_backup_file);
        // Remove backup files generated by backup function
        for (unsigned i = 0; i < 10; ++i) { // Assuming max 10 backups for robustness
            char buf[64];
            snprintf(buf, sizeof(buf), "%s_%u.txt", "test_backup", i);
            remove(buf);
        }

    }

    const char* test_filename;
    const char* test_binary_filename;
    const char* test_copy_src;
    const char* test_copy_dst;
    const char* test_backup_file;
    const char* test_backup_dir;
};

TEST_F(FileTest, OpenAndClose) {
    handle_t h;
    rc_t rc;

    // Open for write, should create file
    rc = open(h, test_filename, kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(isValid(h));
    EXPECT_TRUE(filesys::isFile(test_filename));
    
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_FALSE(isValid(h));

    // Open for read (should exist now)
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(isValid(h));
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);

    // Open non-existent file for read (should fail)
    rc = open(h, "non_existent.txt", kReadFl);
    EXPECT_EQ(rc, kOpenFailRC);
    EXPECT_FALSE(isValid(h));

    // Open with invalid flags
    rc = open(h, test_filename, 0); // No read/write/append flag
    EXPECT_EQ(rc, kInvalidArgRC);

    // Open with nullptr filename
    rc = open(h, nullptr, kWriteFl);
    EXPECT_EQ(rc, kInvalidArgRC);

    // Open with empty filename
    rc = open(h, "", kWriteFl);
    EXPECT_EQ(rc, kInvalidArgRC);

    h.clear();
    rc = close(h);
    EXPECT_EQ(rc, kOkRC); // Should gracefully handle
}

TEST_F(FileTest, SpecialFiles) {
    handle_t h;
    rc_t rc;

    // Test stdout
    rc = open(h, "ignored", kStdoutFl | kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(isValid(h));
    EXPECT_STREQ(name(h), "stdout");
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);

    // Test stderr
    rc = open(h, "ignored", kStderrFl | kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(isValid(h));
    EXPECT_STREQ(name(h), "stderr");
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);

    // Test stdin
    rc = open(h, "ignored", kStdinFl | kReadFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(isValid(h));
    EXPECT_STREQ(name(h), "stdin");
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);
}

TEST_F(FileTest, LastRC) {
    handle_t h;
    rc_t rc;

    // Initial state, lastRC should be kOkRC
    rc = open(h, test_filename, kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(lastRC(h), kOkRC);
    close(h);

    // After a failed open
    rc = open(h, "non_existent.txt", kReadFl);
    EXPECT_EQ(rc, kOpenFailRC);
    // lastRC of invalid handle isn't well-defined by current API, but previous call set rc.

    // After a failed read
    createTempFile(test_filename, "data");
    open(h, test_filename, kReadFl);
    char buf[1];
    read(h, buf, 100); // Try to read more than available
    EXPECT_EQ(lastRC(h), kEofRC); // Should be EOF after attempting to read past end
    close(h);

    // After a successful read
    createTempFile(test_filename, "data");
    open(h, test_filename, kReadFl);
    read(h, buf, 1);
    EXPECT_EQ(lastRC(h), kOkRC);
    close(h);
}

TEST_F(FileTest, ReadAndWrite) {
    handle_t h;
    rc_t rc;
    const char* test_content = "Hello, cwFile!";
    unsigned content_len = strlen(test_content);
    char read_buf[20];
    unsigned actual_read_bytes;

    // Write content
    rc = open(h, test_filename, kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    rc = write(h, test_content, content_len);
    ASSERT_EQ(rc, kOkRC);
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);

    // Read content
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    rc = read(h, read_buf, content_len, &actual_read_bytes);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(actual_read_bytes, content_len);
    read_buf[content_len] = '\0'; // Null-terminate for string comparison
    EXPECT_STREQ(read_buf, test_content);
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);

    // Read less than available
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    rc = read(h, read_buf, 5, &actual_read_bytes);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(actual_read_bytes, 5);
    read_buf[5] = '\0';
    EXPECT_STREQ(read_buf, "Hello");
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);

    // Read more than available (should hit EOF)
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    rc = read(h, read_buf, content_len + 5, &actual_read_bytes);
    EXPECT_EQ(rc, kEofRC); // Should return kEofRC
    EXPECT_EQ(actual_read_bytes, content_len);
    read_buf[actual_read_bytes] = '\0';
    EXPECT_STREQ(read_buf, test_content);
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);

    // Write 0 bytes
    rc = open(h, test_filename, kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    rc = write(h, test_content, 0); // Should be ok
    ASSERT_EQ(rc, kOkRC);
    rc = close(h);
    ASSERT_EQ(rc, kOkRC);
    unsigned current_size;
    file::byteCountFn(test_filename, current_size);
    EXPECT_EQ(current_size, 0);

    // Read with nullptr buf (should crash or return error)
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(read(h, nullptr, 1, nullptr), kInvalidArgRC); // Expect assert or crash
    close(h);
}

TEST_F(FileTest, SeekAndTell) {
    handle_t h;
    rc_t rc;
    const char* content = "0123456789";
    createTempFile(test_filename, content);

    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    
    long current_pos;

    // Tell initial position
    rc = tell(h, &current_pos);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(current_pos, 0);

    // Seek SET
    rc = seek(h, kBeginFl, 5); // Seek to 5th byte from beginning
    ASSERT_EQ(rc, kOkRC);
    rc = tell(h, &current_pos);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(current_pos, 5);

    // Seek CUR
    rc = seek(h, kCurFl, 2); // Advance 2 bytes from current (5+2=7)
    ASSERT_EQ(rc, kOkRC);
    rc = tell(h, &current_pos);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(current_pos, 7);

    // Seek END
    rc = seek(h, kEndFl, -3); // 3 bytes from end (length 10, so 10-3=7)
    ASSERT_EQ(rc, kOkRC);
    rc = tell(h, &current_pos);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(current_pos, 7);

    // Read after seek
    char buf[5];
    read(h, buf, 3);
    buf[3] = '\0';
    EXPECT_STREQ(buf, "789");

    // Seek beyond EOF (should be handled by OS, ftell might return EOF or current size)
    rc = seek(h, kEndFl, 5); // Seek 5 bytes past end
    ASSERT_EQ(rc, kOkRC);
    rc = tell(h, &current_pos);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(current_pos, 15); // ftell should report current position

    // Seek with invalid flags
    rc = seek(h, (seekFlags_t)0xFF, 0); // Invalid seek flag
    EXPECT_EQ(rc, kInvalidArgRC);

    close(h);
}

TEST_F(FileTest, Eof) {
    handle_t h;
    const char* content = "a\n"; // 2 bytes
    createTempFile(test_filename, content);

    rc_t rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);

    // Not at EOF initially
    EXPECT_FALSE(eof(h));

    char buf[2];
    read(h, buf, 1); // Read 'a'
    EXPECT_FALSE(eof(h));

    read(h, buf, 1); // Read '\n'
    EXPECT_FALSE(eof(h));

    read(h, buf, 1); // Read past EOF
    EXPECT_TRUE(eof(h)); // Now at EOF
    EXPECT_EQ(lastRC(h), kEofRC); // Check lastRC for EOF

    close(h);
}

TEST_F(FileTest, ByteCount) {
    handle_t h;
    rc_t rc;

    // Empty file
    createTempFile(test_filename, "");
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(byteCount(h), 0);
    close(h);

    // Non-empty file
    const char* content = "12345";
    createTempFile(test_filename, content);
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(byteCount(h), strlen(content));
    close(h);

    // Special files (should return 0 or depend on OS/stream state)
    rc = open(h, "ignored", kStdinFl | kReadFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(byteCount(h), 0); // Stdin byteCount is 0 or -1 in some systems
    close(h);
}

TEST_F(FileTest, ByteCountFn) {
    rc_t rc;
    unsigned size;

    // Existing file
    const char* content = "some content";
    createTempFile(test_filename, content);
    rc = byteCountFn(test_filename, size);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(size, strlen(content));

    // Non-existent file
    rc = byteCountFn("non_existent.txt", size);
    EXPECT_EQ(rc, kOpenFailRC);
    EXPECT_EQ(size, 0); // Should be 0 on error

    // Null filename
    rc = byteCountFn(nullptr, size);
    EXPECT_EQ(rc, kInvalidArgRC);

}

TEST_F(FileTest, Compare) {
    rc_t rc;
    bool is_equal;

    const char* content1 = "file content one";
    const char* content2 = "file content two";
    const char* content_long = "file content one longer";

    // Identical files
    createTempFile("file1.txt", content1);
    createTempFile("file2.txt", content1);
    rc = compare("file1.txt", "file2.txt", is_equal);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(is_equal);

    // Different content
    createTempFile("file3.txt", content1);
    createTempFile("file4.txt", content2);
    rc = compare("file3.txt", "file4.txt", is_equal);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_FALSE(is_equal);

    // Different size
    createTempFile("file5.txt", content1);
    createTempFile("file6.txt", content_long);
    rc = compare("file5.txt", "file6.txt", is_equal);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_FALSE(is_equal);

    // One non-existent file
    rc = compare("file1.txt", "non_existent.txt", is_equal);
    EXPECT_EQ(rc, kOpenFailRC);

    // Both non-existent files
    rc = compare("non_existent1.txt", "non_existent2.txt", is_equal);
    EXPECT_EQ(rc, kOpenFailRC);

    // Null filename
    rc = compare(nullptr, "file1.txt", is_equal);
    EXPECT_EQ(rc, kInvalidArgRC);

    // Cleanup
    remove("file1.txt");
    remove("file2.txt");
    remove("file3.txt");
    remove("file4.txt");
    remove("file5.txt");
    remove("file6.txt");
}

TEST_F(FileTest, Name) {
    handle_t h;
    rc_t rc;

    // Name of opened file
    createTempFile(test_filename, "");
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(name(h), test_filename);
    close(h);

    // Name of special file
    rc = open(h, "ignored", kStdoutFl | kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(name(h), "stdout");
    close(h);

    // Invalid handle (should assert)
    h.clear();
    EXPECT_DEATH(name(h), "");
}

TEST_F(FileTest, FnWrite) {
    rc_t rc;
    const char* content = "write this text";
    unsigned content_len = strlen(content);
    
    // Write to a new file
    rc = fnWrite(test_filename, content, content_len, kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(readFileToString(test_filename).c_str(), content);

    // Overwrite existing file
    rc = fnWrite(test_filename, "new", 3, kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(readFileToString(test_filename).c_str(), "new");

    // Append to file
    rc = fnWrite(test_filename, " appended", strlen(" appended"), kAppendFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(readFileToString(test_filename).c_str(), "new appended");

    // Write with 0 bytes
    rc = fnWrite(test_filename, content, 0, kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(readFileToString(test_filename).c_str(), ""); // File should be empty
    

    // Write with nullptr buf
    rc = fnWrite(test_filename, nullptr, 10, kWriteFl); // Should still create/truncate file
    EXPECT_EQ(rc, kInvalidArgRC);
    EXPECT_STREQ(readFileToString(test_filename).c_str(), "");
    
    
    // Write to invalid path (e.g., non-existent directory without creation flag)
    rc = fnWrite("non_existent_dir/file.txt", content, content_len, kWriteFl);
    EXPECT_EQ(rc, kOpenFailRC);
    
}

TEST_F(FileTest, Copy) {
    rc_t rc;
    const char* content = "content to copy";
    createTempFile(test_copy_src, content);

    // Simple copy
    rc = copy(nullptr, test_copy_src, nullptr, nullptr, test_copy_dst, nullptr);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(filesys::isFile(test_copy_dst));
    EXPECT_STREQ(readFileToString(test_copy_dst).c_str(), content);

    // Copy with directory and extension parts
    filesys::makeDir("temp_dir");
    createTempFile("temp_dir/original.log", "log data");
    rc = copy("temp_dir", "original", "log", "temp_dir", "copy", "txt");
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(filesys::isFile("temp_dir/copy.txt"));
    EXPECT_STREQ(readFileToString("temp_dir/copy.txt").c_str(), "log data");


    // Source file does not exist
    rc = copy(nullptr, "non_existent_src.txt", nullptr, nullptr, test_copy_dst, nullptr);
    EXPECT_EQ(rc, kOpenFailRC);

    // Invalid destination path (e.g., non-existent directory)
    rc = copy("non_existent_dir", test_copy_src, nullptr, nullptr, test_copy_dst, nullptr);
    EXPECT_EQ(rc, kOpenFailRC); // makeFn will fail to resolve non_existent_dir

    // Copy empty file
    createTempFile("empty.txt", "");
    rc = copy(nullptr, "empty.txt", nullptr, nullptr, "empty_copy.txt", nullptr);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(readFileToString("empty_copy.txt").c_str(), "");
    remove("empty.txt");
    remove("empty_copy.txt");
}

TEST_F(FileTest, Backup) {
    rc_t rc;
    const char* content = "original content";
    createTempFile(test_backup_file, content); // test_backup.txt

    // Create first backup
    rc = backup(test_backup_file, nullptr); // Default dst_dir is same as src
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(filesys::isFile("test_backup_0.txt"));
    EXPECT_STREQ(readFileToString("test_backup_0.txt").c_str(), content);

    // Create second backup (should increment number)
    rc = backup(test_backup_file, nullptr);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(filesys::isFile("test_backup_1.txt"));
    EXPECT_STREQ(readFileToString("test_backup_1.txt").c_str(), content);

    // Backup to a different directory
    filesys::makeDir(test_backup_dir);
    rc = backup(test_backup_file, test_backup_dir);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_TRUE(filesys::isFile("test_backup_dir/test_backup_2.txt")); // Note: naming continues
    EXPECT_STREQ(readFileToString("test_backup_dir/test_backup_2.txt").c_str(), content);

    // Backup non-existent file (should return kOkRC, do nothing)
    rc = backup("non_existent.txt", nullptr);
    EXPECT_EQ(rc, kOkRC);
    EXPECT_FALSE(filesys::isFile("non_existent_0.txt")); // Ensure no file was created
}

TEST_F(FileTest, ToBufAndToStr) {
    rc_t rc;
    handle_t h;
    const char* content = "Binary\nData\0With\0Nulls"; // Contains nulls
    const unsigned content_len = strlen(content) + 1 + strlen("With") + 1 + strlen("Nulls"); // Actual byte count

    createTempFile(test_binary_filename, content, kWriteFl | kBinaryFl, content_len);

    // fnToBuf - reads exact bytes, including nulls
    unsigned actual_len_buf = 0;
    char* buf = fnToBuf(test_binary_filename, &actual_len_buf);
    ASSERT_NE(buf, nullptr);
    EXPECT_EQ(actual_len_buf, content_len);
    EXPECT_EQ(memcmp(buf, content, content_len), 0);
    mem::release(buf);

    // fnToStr - reads until first null, or maxCharN
    unsigned actual_len_str = 0;
    char* str = fnToStr(test_binary_filename, &actual_len_str);
    ASSERT_NE(str, nullptr);
    // fnToStr (internally _fileToBuf(h,1,...)) adds an extra null terminator, 
    // so it should read up to the first null, or the full length if no null.
    // The current _fileToBuf(h, 1, ...) means it will read 'n' bytes and add 1 more '\0'
    // This will lead to the string being truncated at the first null character in content
    // content = "Binary\nData\0With\0Nulls"
    // textLength("Binary\nData") is 11.
    EXPECT_STREQ(str, "Binary\nData");
    EXPECT_EQ(actual_len_str, content_len);
    mem::release(str);

    // toBuf with handle
    rc = open(h, test_binary_filename, kReadFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    buf = toBuf(h, &actual_len_buf);
    ASSERT_NE(buf, nullptr);
    EXPECT_EQ(actual_len_buf, content_len);
    EXPECT_EQ(memcmp(buf, content, content_len), 0);
    mem::release(buf);
    close(h);

    // toStr with handle
    rc = open(h, test_binary_filename, kReadFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    str = toStr(h, &actual_len_str);
    ASSERT_NE(str, nullptr);
    EXPECT_STREQ(str, "Binary\nData");
    EXPECT_EQ(actual_len_str, content_len);
    mem::release(str);
    close(h);

    // Test non-existent file
    buf = fnToBuf("non_existent.bin", nullptr);
    EXPECT_EQ(buf, nullptr);
    str = fnToStr("non_existent.txt", nullptr);
    EXPECT_EQ(str, nullptr);

}

TEST_F(FileTest, LineCount) {
    rc_t rc;
    handle_t h;
    unsigned count;

    // Empty file
    createTempFile(test_filename, "");
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    rc = lineCount(h, count);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(count, 0); 
    close(h);

    // Single line, no newline
    createTempFile(test_filename, "line1");
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    rc = lineCount(h, count);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(count, 1); // fgetc loop, EOF increments once
    close(h);

    // Single line, with newline
    createTempFile(test_filename, "line1\n");
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    rc = lineCount(h, count);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(count, 1);
    close(h);

    // Multiple lines
    createTempFile(test_filename, "line1\nline2\nline3");
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    rc = lineCount(h, count);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(count, 3);
    close(h);

    // Multiple lines, ending with newline
    createTempFile(test_filename, "line1\nline2\n");
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    rc = lineCount(h, count);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(count, 2);
    close(h);
}

TEST_F(FileTest, GetLine) {
    rc_t rc;
    handle_t h;
    const char* content = "Line One\nLine Two\nLast Line";
    createTempFile(test_filename, content);

    constexpr unsigned bufN = 20;
    char buf[bufN];
    unsigned buf_len = sizeof(buf);
    
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    
    // Read first line
    buf_len = sizeof(buf);
    rc = getLine(h, buf, buf_len);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(buf, "Line One\n");
    EXPECT_EQ(buf_len, bufN); // Size of "Line One\n"

    // Read second line
    rc = getLine(h, buf, buf_len);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(buf, "Line Two\n");
    EXPECT_EQ(buf_len, bufN); // Size of "Line Two\n"

    // Read last line (no trailing newline)
    buf_len = sizeof(buf);
    rc = getLine(h, buf, buf_len);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(buf, "Last Line");
    EXPECT_EQ(buf_len, bufN); // Size of "Last Line"

    // Read past EOF
    buf_len = sizeof(buf);
    rc = getLine(h, buf, buf_len);
    EXPECT_EQ(rc, kEofRC);

    close(h);
    
    
    // Test kBufTooSmallRC
    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);
    char small_buf[5]; // Too small for "Line One\n"
    buf_len = sizeof(small_buf);
    rc = getLine(h, small_buf, buf_len);
    EXPECT_EQ(rc, kBufTooSmallRC);
    EXPECT_EQ(buf_len, strlen("Line One\n") + 3); // Expected buffer size + 3 as per implementation

    close(h);
}

TEST_F(FileTest, GetAutoLine) {
    rc_t rc;
    handle_t h;
    const char* content = "Short Line\nMedium Line With Some Content\nVery Long Line That Exceeds Initial Buffer Size And Needs Resizing Multiple Times\nEnd.";
    createTempFile(test_filename, content);

    rc = open(h, test_filename, kReadFl);
    ASSERT_EQ(rc, kOkRC);

    char* buf = nullptr;
    unsigned buf_len = 0;

    // Read Short Line
    rc = getLineAuto(h, &buf, buf_len);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(buf, "Short Line\n");
    mem::release(buf); buf_len = 0;

    // Read Medium Line
    rc = getLineAuto(h, &buf, buf_len);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(buf, "Medium Line With Some Content\n");
    mem::release(buf); buf_len = 0;

    // Read Very Long Line (should trigger resizing)
    rc = getLineAuto(h, &buf, buf_len);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(buf, "Very Long Line That Exceeds Initial Buffer Size And Needs Resizing Multiple Times\n");
    mem::release(buf); buf_len = 0;

    // Read End Line
    rc = getLineAuto(h, &buf, buf_len);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(buf, "End.");
    mem::release(buf); buf_len = 0;

    // Read past EOF
    rc = getLineAuto(h, &buf, buf_len);
    EXPECT_EQ(rc, kEofRC);
    EXPECT_EQ(buf, nullptr); // Should be nullptr after EOF
    mem::release(buf); // Still call to be safe (should be no-op)

    close(h);
}

TEST_F(FileTest, TypeSpecificReadWrite) {
    handle_t h;
    rc_t rc;
    
    // Test writeInt and readInt
    int write_val = 12345;
    int read_val = 0;
    rc = open(h, test_binary_filename, kWriteFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = writeInt(h, &write_val);
    ASSERT_EQ(rc, kOkRC);
    close(h);

    rc = open(h, test_binary_filename, kReadFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = readInt(h, &read_val);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(read_val, write_val);
    close(h);

    // Test writeFloat and readFloat
    float write_float = 3.14159f;
    float read_float = 0.0f;
    rc = open(h, test_binary_filename, kWriteFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = writeFloat(h, &write_float);
    ASSERT_EQ(rc, kOkRC);
    close(h);

    rc = open(h, test_binary_filename, kReadFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = readFloat(h, &read_float);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_FLOAT_EQ(read_float, write_float);
    close(h);

    // Test multiple values
    int write_arr[] = {10, 20, 30};
    int read_arr[3] = {0};
    rc = open(h, test_binary_filename, kWriteFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = writeInt(h, write_arr, 3);
    ASSERT_EQ(rc, kOkRC);
    close(h);

    rc = open(h, test_binary_filename, kReadFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = readInt(h, read_arr, 3);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_EQ(read_arr[0], 10);
    EXPECT_EQ(read_arr[1], 20);
    EXPECT_EQ(read_arr[2], 30);
    close(h);
}

TEST_F(FileTest, WriteReadStr) {
    handle_t h;
    rc_t rc;
    const char* test_str = "This is a test string for writeStr and readStr.";
    char* read_str_ptr = nullptr;

    // Write string
    rc = open(h, test_filename, kWriteFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = writeStr(h, test_str);
    ASSERT_EQ(rc, kOkRC);
    close(h);

    // Read string
    rc = open(h, test_filename, kReadFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = readStr(h, &read_str_ptr, 0); // Use default maxCharN
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(read_str_ptr, test_str);
    mem::release(read_str_ptr);
    close(h);

    // Write empty string
    rc = open(h, test_filename, kWriteFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = writeStr(h, "");
    ASSERT_EQ(rc, kOkRC);
    close(h);

    // Read empty string
    rc = open(h, test_filename, kReadFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = readStr(h, &read_str_ptr, 0);
    ASSERT_EQ(rc, kOkRC);
    EXPECT_STREQ(read_str_ptr, "");
    mem::release(read_str_ptr);
    close(h);

    // Test maxCharN limit
    rc = open(h, test_filename, kWriteFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = writeStr(h, "long string");
    ASSERT_EQ(rc, kOkRC);
    close(h);

    rc = open(h, test_filename, kReadFl | kBinaryFl);
    ASSERT_EQ(rc, kOkRC);
    rc = readStr(h, &read_str_ptr, 5); // Max char N too small
    EXPECT_EQ(rc, kInvalidArgRC); // Should return error
    EXPECT_EQ(read_str_ptr, nullptr); // No memory allocated
    close(h);
}

TEST_F(FileTest, PrintfFunctions) {
    handle_t h;
    rc_t rc;

    // Test print
    rc = open(h, test_filename, kWriteFl);
    ASSERT_EQ(rc, kOkRC);
    rc = print(h, "Simple text.\n");
    ASSERT_EQ(rc, kOkRC);
    close(h);
    EXPECT_STREQ(readFileToString(test_filename).c_str(), "Simple text.\n");

    // Test printf
    rc = open(h, test_filename, kAppendFl); // Append to existing
    ASSERT_EQ(rc, kOkRC);
    rc = printf(h, "Formatted: %s %d\n", "value", 123);
    ASSERT_EQ(rc, kOkRC);
    close(h);
    EXPECT_STREQ(readFileToString(test_filename).c_str(), "Simple text.\nFormatted: value 123\n");

    // Test vPrintf (indirectly via printf) is working
}
